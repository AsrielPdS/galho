import { Properties } from "./css";
import type { EventHandler, HTMLEventMap, SVGEventMap, S as _S, E } from "./galho";
export declare type S = HTMLElement | SVGElement;
export declare type Create = keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap | S;
declare type SS<T extends S> = T | _S<T>;
export declare const isS: (value: unknown) => value is string;
export declare const isF: (value: unknown) => value is Function;
export declare function css<T extends S, P extends keyof Properties>(e: T, property: P): string;
export declare function css<T extends S, P extends keyof Properties>(e: T, property: P, value: Properties[P]): T;
export declare function css<T extends S>(e: T, styles: Properties): T;
export declare function g<K extends keyof HTMLElementTagNameMap>(element: K, props?: string | string[] | 0, childs?: any): HTMLElementTagNameMap[K];
export declare function g<T extends HTMLElement = HTMLElement>(element: Create, props?: string | string[] | 0, childs?: any): T;
export declare function div<K extends keyof HTMLElementTagNameMap>(props?: Partial<HTMLElementTagNameMap[K]> | string | string[] | 0, childs?: any): HTMLDivElement;
export declare function div<T extends HTMLElement = HTMLElement>(props?: Partial<T> | string | string[] | 0, childs?: any): HTMLDivElement;
export declare function add(e: ParentNode, child: any): void;
export declare function put(e: Element, position: InsertPosition, child: any): void;
export declare function on<T extends S>(e: T, actions: HTMLEventMap<T>, options?: AddEventListenerOptions): T;
export declare function on<T extends S>(e: T, actions: SVGEventMap<T>, options?: AddEventListenerOptions): T;
export declare function on<T extends S, K extends keyof HTMLElementEventMap>(e: T, action: K, listener: (this: T, e: HTMLElementEventMap[K]) => any, options?: AddEventListenerOptions): T;
export declare function on<T extends S, K extends keyof SVGElementEventMap>(e: T, action: K, listener: (this: T, e: SVGElementEventMap[K]) => any, options?: AddEventListenerOptions): T;
export declare function on<T extends Element = Element, E extends Event = Event>(e: T, action: string, fn: EventHandler<T, E>, options?: AddEventListenerOptions): T;
export declare function on<T extends S, K extends keyof HTMLElementEventMap>(e: T, action: K[], listener: (this: T, e: HTMLElementEventMap[K]) => any, options?: AddEventListenerOptions): T;
export declare function delay<T extends S, K extends keyof HTMLElementEventMap>(e: SS<T>, action: K, delay: number, listener: (this: T, e: HTMLElementEventMap[K]) => any): T;
export declare function delay<T extends S, K extends keyof SVGElementEventMap>(e: SS<T>, action: K, delay: number, listener: (this: T, e: SVGElementEventMap[K]) => any): T;
export declare function delay<T extends S, E extends Event = Event>(e: SS<T>, action: string, delay: number, fn: EventHandler<T, E>): T;
export declare function one<T extends S>(e: T, actions: HTMLEventMap<T>): T;
export declare function one<T extends S>(e: T, actions: SVGEventMap<T>): T;
export declare function one<T extends S, K extends keyof HTMLElementEventMap>(e: T, action: K, listener: (this: HTMLElement, e: HTMLElementEventMap[K]) => any): T;
export declare function one<T extends S, K extends keyof SVGElementEventMap>(e: T, action: K, listener: (this: SVGElement, e: SVGElementEventMap[K]) => any): T;
export declare function one<T extends S>(e: T, action: string, listener: (this: Element, e: Event) => any): T;
export declare function frag<T extends S>(e: T, child: any): T;
export declare function bind<T extends S, M>(e: T, prop: keyof T, src: E<M>, field: keyof M): T;
export declare function bind<T extends S, M>(e: T, prop: keyof T, src: E<M>, expression: string): T;
export declare function bind<T extends S, U extends S>(e: T, prop: keyof T, src: S, field: keyof U): T;
export declare function bind<T extends S>(e: T, prop: keyof T, src: S, expression: string): T;
export declare function bind<T extends S, U extends Object>(e: T, prop: keyof T, src: U, field: keyof U): T;
export declare function bind<T extends S>(e: T, prop: keyof T, src: Object, expression: string): T;
export declare function focusin<T extends S>(e: T, handler?: (e: FocusEvent) => any): T;
export declare function focusout<T extends S>(e: SS<T>, handler?: (e: FocusEvent) => any): SS<T>;
export declare function index<T extends S>(e: T): number;
export declare function indexInDocument(e: Element): number;
export declare function childByCls<T extends S>(e: T, cls: string): S;
export declare function count<T extends S>(e: T): number;
export declare function fullHtml<T extends S>(e: SS<T>): string;
export declare function isEmpty<T extends S>(e: SS<T>): boolean;
export declare function rect<T extends S>(e: SS<T>): DOMRect;
export declare function focused<T extends S>(e: SS<T>): boolean;
export declare function prevE<T extends S>(e: T): Element;
export declare function prev<T extends Node>(e: T): ChildNode;
export declare function parent<T extends Node>(e: T): HTMLElement;
export declare function text<T extends Node>(e: T): string;
export declare function last<T extends Node>(e: T): ChildNode;
export declare function contains<T extends S>(e: SS<T>, child: S | Node): boolean;
export declare function inDOM<T extends S>(e: T): boolean;
export declare function tag<T extends S>(e: T): string;
export declare function isInput<T extends S>(e: SS<T>): boolean;
export declare function vScroll<T extends S>(e: SS<T>, value: number, type?: ScrollBehavior): void;
export declare function width<T extends HTMLElement>(e: SS<T>): number;
export declare function height<T extends HTMLElement>(e: SS<T>): number;
export declare const isSelection: <T extends S>(value: any) => value is _S<T>;
export declare function is<T extends S>(e: SS<T>, filter: string): boolean;
export declare function is<T extends S>(e: SS<T>, filter: EventTarget): boolean;
export declare function is<T extends S>(e: SS<T>, filter: S): boolean;
export declare function isCls<T extends S>(e: T, cls: string): boolean;
export declare function when<T extends S>(e: T, selector: string, action: (e: T) => T): T;
export declare function putIn<T extends S>(e: T, position: InsertPosition, parent: Element | S): T;
export {};
